--
-- this is ~/cheapthreads/ctc/ct/defunctionalizer/defun.log.txt
--
-- a development log for the defunctionalizer
--
-- created 09.02.09
--
--  Schulz
--

----------------------------------------------------------------------
-- 09.02.09
----------------------------------------------------------------------

Finished code for inlining function applications.  Discussions
with Bill and Adam indicate that 'get' and 'put' applications should
never have a fix-point function as an argument; as such,
fix-point applications are not inline, although all non-fix applications
occuring in the body of a fix-point application WILL be inlined.

Note that the result of inlining as presently implemented slightly
changes the scoping rules; in particular, substiution due to inlining
may (possibly) override local bindings (particularly in case statements)
if these shadow formal parameters of the function being inlined.
This should not present a serious problem, since all lambda-bound
variables are force to unique identifiers by suffixing each with 
the name of its binding function.

However, we note the subtlety here, in case problems should arise.

The final result of inlining should be that non-fix functions
behave effectively like macros.

The purpose of inlining is to remove the need for any reference
to function declarations when defining the transition functions
generated by the K-defunctionalizer.

Correctness abstract syntax tree resulting from inlining as implemented
still needs to be checked.

LATER:

Tweaked forcing of unique identifiers for lambda-bound variables
to try to prevent possible (though unlikely) shadowing of local bindings;
this is accomplished by catting a space, plus the corresponding
function identifier to each and replacing all parameters accordingly.
(It seems reasonable to assume that the parser will not allow spaces
within an identifier.)

Tweaked inliner to ensure that no attempt is made to inline 'get'
or 'put' applications, since these are function applications in the
abstract syntax.

Still needs testing.

!! - IMPORTANT - !!
Need another inlining pass to go over possible function applications
in the body of a function.  Can we guarantee that this will terminate?

----------------------------------------------------------------------
-- 10.02.09
----------------------------------------------------------------------

Finished writing K-defunctionalizer.  The defunctionalizer has so far
behaved as expected when presented relatively trivial examples; more
complex cases do not appear to fundamentally alter nature of the
K-defunctionalization, but it would not hurt to try them.

Slightly changed several boilerplate functions, including predicates
isPut and isGet which are used to discriminate applications of 'get'
and 'put' from other function applications.  In particular, made
the pattern to match against slightly more permissive, so that 
isPut and isGet do not check number of arguments or type, only
the name of the function being applied.  Other functions now check
for correct number of arguments.

Altered inliner so that before a parameter is substituted with an
expression, the expression itself is transformed by the inliner,
to ensure that nested function applications are properly inlined.
As a result, function inlineexpr is now recursive.

----------------------------------------------------------------------
-- 11.02.09
----------------------------------------------------------------------

Separated body of code in ./defunk.hs into several additional files, namely
./predefun, ./defuntypes, and ./examples, in order to give a clearer
notion of code organization and progress.

Review of the paper and inspection of the code suggests the
K-defunctionalizer may need small revisions as regards its handling
of types; in particular, it may be necessary in order to properly
distinguish returns in K from returns in R.  This might not be
a problem in a well-formed program, but should be dealt with
just in case.

LATER:

Added definition for 'step' identifier constant.  THIS IS NOT FINAL
as the identifier must also reference a resumption monad.  Add this later.
We may make the provisional assumption that the only monads are K
and the resumption monad R.

----------------------------------------------------------------------
-- 12.02.09
----------------------------------------------------------------------

Began work on R-defunctionalizer; hooked up definitions of necessary
boilerplate functions generated by MonadLab, made slight changes to
type synonyms in dependent files and began translating definitions in
the paper into Haskell.

Found it necessary to add another argument to defunR, because implicit
reference is made to state structure in the definition given in the paper,
i.e., its arity and some means of uniquely indexing its components
must be known in order to define a transition.  Slightly changed return value
of function mkState, which now produces an initial K-state from source
declarations, in the form of an association list in which each element
is a formal parameter that may be permuted or written over by a transition
rule.

Some other miscellaneous boilerplate.

Continuing with the convention of ignoring the type annotations of expressions;
Adam asserts that, in a well-typed expression, the meaning of 'return'
should be unambiguous.

----------------------------------------------------------------------
-- 16.02.09
----------------------------------------------------------------------

Began writing code for fixpoint defunctionalization; unfortunately, it
is not yet immediately clear how to proceed

In particular, there needs to be some express way of associating a unique
label to the "head" of the loop; this may be implementable using the program
counter as-is, or it may require introducing new data types.

Also need to add facility for expressly tagging fixpoint declarations in
the abstract syntax tree, so that these can be tested by the R-defunctionalizer;
also need a predicate to test for these.  The abstract syntax in its
current form has no express 'fix' operation, and so I must assume that this
also is expressed as a function application.

Note also that earlier assumptions about well-typing are being put
to explicit use; the R-defunctionalizer passes a 'return' expression in its
argument as an argument to the K-defunctionalizer.  The two expressions are
identical, including their type annotations.  If express use should need to
be made of the type annotations in the future, this will have to be changed.

LATER:

Regarding defunctionalization of fixpoints, the following hold:

(i) k* (as appearing in the paper) is simply a place-holder label
    signifying the start of the loop; when a fixpoint function is called,
    this label is simply substituted with the appropriate PC value

(ii) kappa (or simply k) is the function itself; when this is called,
     it is applied to new arguments simply by extending the environment
     with the other formal parameters of the fixpoint (the parameters of k)
     and properly substituting them

Also determined that there is an apparent contradiction between Adam's
syntax and the syntax as presented in the paper; specifically,
the grammar implicit in Adam's syntax may not permit nested fixpoints,
which the grammar in the paper does seem to allow.

----------------------------------------------------------------------
-- 17.02.09
----------------------------------------------------------------------

Began writing code for fixpoint defunctionalization; appears consistent with
paper, but thus far has not been tested.  Note that it was necessary to write
fixpoint defunctionalizer as a separate procedure, since there is no
'fix' operator in the abstract syntax, and thus fixpoint defunctionalization
has to occur at the declaration level.

It appears that this latter change may be an indirect result of the
abstract syntax structure; that is, since fixpoint can, in effect,
occur only once in a defunctionalized expression (that is, at the top-level),
there will be only one set of defunctionalization rules to extend the
recursive bindings over.  In particular, this (I think) is why
the [r] patter at the end of defunfix is necessary.

Continued to harp on grammar inconsistency; check later for possibility
that nested loops cause trouble.

----------------------------------------------------------------------
-- 18.02.09
----------------------------------------------------------------------

Finished first complete version of the defunctionalizer code.  This included
filling in cases for sequence and bind in defunR and writing parent
functions to call the defunctionalizer and necessary preprocessing on
the abstract syntax tree.  At least one helper function (namely that for
the bind case of defunR) was taken verbatim from Bill's original
defunctionalizer, and I admit not not fully understanding what it does or
why; keep an eye on this.

Made small changes to preprocesser (in PreDefun) to remove the
CtsProg constructor from declaration lists, as this was unnecessary.
Changed defunR to return lists of RRules rather than individual rules.

Currently uncertain how to project the final rule list out of the
M monad, but I am very tired and my facial tic is returning.

In outline, the defunctionalizer should work as follows:

  (1) get abstract syntax tree from the frontend;
      force all lambda-bound variables to unique names;
      inline all non-fix function applications;

  (2) pass transformed (but semantically equivalent) AST
      to the defunctionalizer; defunctionalizer handles each
      declaration separately; non-fix functions are R-defunctionalized;
      fix funcitons are defunctionalized in a special case
      (as necessitated by the syntax);

  (4) each (possibly recursive) call to R-defunctionalizer
      calls K-defunctionalizer to obtain rules for non-control
      'atoms'; these are used to form controlled transition rules
      that incorporate a program counter; these lists are
      concatenated and returned as the defunctionalizer output

----------------------------------------------------------------------
-- 19.02.09
----------------------------------------------------------------------

Hooked up defunctionalizer to the testing function and found a way
to project the rule list resulting from defunctionalization out
of the M monad; this consists of using 'runM' found in the definitions
generated by MonadLab to project the primitive argument out of the monad and
then applying a series of default arguments to the resulting term
to obtain the final result i.e. a list of rules.

Discovered that the main defunctionalizer is written in a way that it call
defunR on ALL declarations, including those of non-R type; this is incorrect,
and some means will have to be found to distinguish which declarations should
be R-defunctionalized and which should not.

Discovered another problem in the application of fixpoint functions;
these cannot be inlined in the abstract syntax tree because they
are represented as declarations rather than expressions.  It might
be possible to rewrite the defunctionalizer so that it uses an expressly
constructed list of fixpoint functions, but this seems needlessly complicated.
To discuss these issues with Bill an Adam this afternoon.

----------------------------------------------------------------------
-- 23.02.09
----------------------------------------------------------------------

Fixed defunctionalizer so that defunctionalization proceeds
from the main function, with all other declared functions defunctionalized
through recursive descent.  However, as the fixpoint issue is not yet
resolved in the code, all fixpoint functions are then omitted from
defunctionalization; this caused several minor breaks in code written
today, though all new code will all be scrapped, so that the issue is
inconsequential.

Observed what appeared to be successful defunctionalization in at least
one very restricted instance (no fixpoints).

----------------------------------------------------------------------
-- 24.02.09
----------------------------------------------------------------------

Changed defunctionalizer to reflect changes to abstract syntax, i.e.
removal of the special "fix" function declaration and addition of
Expr -> fix(Expr) into the grammar.

Defunctionalizer now produces a sequence of rules for the example program
in ~/cheapthreads/ctc/tests/ex1.hs; however, no other test programs
work without crashing.  It should be noted that most of these crashes
are because the programs in question have no main function; with
small modifications (i.e. adding a main function) I expect at least some
of them to work.

Added a case to the expression substitution function in PreDefun.hs to
deal with new case in grammar; added case to defunR and removed
function for dealing specially with the "fix-function" declaration.  It
should be noted that several bits of code are taken verbatim (or almost)
from earlier code in Bill's original Defunctionalizer.hs; upon further
inspection, I think I understand them, though the fact that I had to borrow
them exactly makes me somewhat nervous regarding their correctness in the
context of the new code.

Discovered a problem arising from the output of the frontend, specifically
as relates to sequences of two or more '>>'; presently, the frontend
parses the first and second identifiers as function applications, and
the third as a variable identifier; this causes the defunctionalizer to crash,
as defunctionalizing a variable by itself has no meaning.  Discussed this
with Adam, though have not settled on a final solution.

Added a case to defunctionalization of fixpoints to deal with the recursive
call itself; this is one of the features dealt with by borrowing code
from Bill; there is a temporary stub in PreDefun that 'tests' for
a recursive call inside of a fixpoint in order to trigger this action,
the predicate presently returns 'True' for all values.  In particular,
the issue of identifying a recursive (versus other) call needs to be dealt
with explicitly, even if only in the form of assurances that a function
application in this position will always be a recursive call.

Next step: test other cases WITH a main function; check correctness of
multiple null binds and check for similar problems in other chained operators;
deal with forming recursive calls with better assurance of correctness.

----------------------------------------------------------------------
-- 27.02.09
----------------------------------------------------------------------

Added fix for previously observed problem with multiple null-binds;
as it turns out, the problem was not with chained operators. The problem
arose because the parser outputs applications of zero-arity functions
as variables, with lead to bad cases being passed to the defunctionalizer.
The problem appears to be resolved by traversing the AST and replacing
all variable instances that match a zero-arity function in the
declaration table with a corresponding application.

Observed what appears to be a problem with the inliner; in particular,
it appears that function applications are not being inlined at all.
This presently causes the defunctionalizer to throw an exception and
stop execution, as it has been previously assumed that only 'get'
and 'put' applications would appear in the AST at time of defunctionalization.

----------------------------------------------------------------------
-- 01.03.09
----------------------------------------------------------------------

Fixed inliner; in haste to construct one, had overlooked the need to
recursively descend the entire expression tree.  Thus, only applications
at the top syntactic level were being inlined.  This resolved the observed
problem.

Tweaked several features to ensure that 'get', 'put', and 'step' are properly
identified and dealt with during preprocessing.

Several issues with preprocessing still remain.  In particular,
built-in functions such as (+) and (-) will need to be given
definitions in the FEnv; otherwise, attempts to defunctionalize them
will fail.  Wrote a temporary kludge (dated) into inlineexpr in the
process of exploring the problem; this lets function applications
for which no declaration is found simply "pass through" to the
defunctionalizer.  Suggest placing definitions for built-ins
into FEnv by default.

Also have not fully resolved the issue surrounding the nullary
function rewriter; it is not being fully applied to the AST,
as suggested by the fact that some current issues were resolved
by applying rwnullary before and after inlining.  It should
be determined whether the change in behavior occurs because
the function is applied twice, or because it is applied before
and after inlining.  The cases in question are commented out
in the top-level preprocessing function, prepast.

----------------------------------------------------------------------
-- 03.03.09
----------------------------------------------------------------------

Changes and improvements to preprocessing, specifically an inliner
that I now believe is correct in proper generality.  However,
it should be noted that the correctness of the inliner depends
upon the (appropriate) assumption that mutual recursion does not occur
in a well-formed program.

Wrote kludge-built-in functions for "+" and "-"; this solution does
not presently appear satisfactory, as it is not immediately
apparent how the defunctionalizer should resolve such expressions
as pure productions of the (current) syntax.

Several bugs still appear to exist in preprocessing; to be ironed out.

----------------------------------------------------------------------
-- 04.03.09
----------------------------------------------------------------------

Continued work on the preprocessor.  Specifically, extended
the state processing function to allocate K-entries for
parameters appearing in the lambda expression for a 'bind'
or 'fix' expression.  Rewriting of variable names now precedes
other preprocessing, so that the sequence now is: (1) force unique
variable names; (2) get initial declaration environment;
(3) inline all function applications; (4) update the declaration
environment to reflect the inlining, and (5) rewrite nullary
function applications to proper syntax (i.e. from 'Var' to 'App').

Unfortunately, improperly specified nullary applications appear to be
finding their way into the final preprocessed AST, again.

Made several small changes to scheme for forcing identifiers,
to ensure internal consistency.

Slightly improved upon addition/subtraction kludge, so that these are
rewritten by the preprocessor into a particularly formatted tuple
in the abstract syntax, which the evaluator has a special case
to deal with.

----------------------------------------------------------------------
-- 06.03.09
----------------------------------------------------------------------

Further work on the preprocessor.  Resolved most of the persistent small
issues regarding the creation and passing of unique, consistent identifiers
in the AST and the state tuple.

At this time, one in particular persists, namely the failure of variables
inside a 'put' application to be properly rewrittien; currently, it appears thatthey are not rewritten at all.

Addition and subtraction still appear to present problems.

----------------------------------------------------------------------
-- 12.03.09
----------------------------------------------------------------------

Defunctionalizer now produces a FSM for the DSLWC example
(i.e. in "~/cheapthreads/ctc/tests/dslwc.hs").

Located and fixed the final known bug in the preprocessor; this was the result
of a simple oversight in coding the cases for the variable-name rewriter
in function uniqlbv.  Specifically, the variable rewrite was not applied
to the body of fixpoint applications.

Devised an improved solution to the problem of handling "+" and "-"; this
passes over "+" and "-" applications in the concrete syntax and passes
them as function applications to the defunctionalizer; the evaluator
then wraps them in a primitive operation constructor (PrimOp, which is
constructed from an additional case, DFPOp, of DefunVal) which is
returned as a value for its respective state in the FSM.  The primitive
can then be evaluated at runtime, when the corresponding operands
(some of which may be input-dependent variables) can be expected to
be properly instantiated.  It is my opinion that this should be sufficient
to handle the problem of primitives/built-ins for now.

----------------------------------------------------------------------
-- 17.03.09
----------------------------------------------------------------------

Wrote a pretty-printer for the final defunctionalizer output; the details
are unremarkable, though this should be useful in writing a simple
step-through executor for debugging.

Discovered that jump- and destination-label identifiers were being
inconsistently named; this was partially due to a minor coding oversight
and partially due to a need to rename the kappa-identifiers in
a way consistent between declarations in a fix-bound lambda expression
and the formation of their corresponding recursive calls in the
R-defunctionalizer.

For now this problem has been corrected by simply disabling the
renaming of the first parameter in a fix-bound lambda, which is assumed
to be the fixpoint label.  This seems reasonable, as this is has the
effect of binding a recursive call to the nearest lexically enclosing
fixpoint label.  Moreover, the first parameter, assumed to a fixpoint
label, should not be 'assigned' at any point in the program, and so
should not be given a state component.

Tweaked variable renaming conventions so that fixpoint labels are not
changed at all at any point in the AST during preprocessing.  Existing
code should implement this convention.

----------------------------------------------------------------------
-- 18.03.09
----------------------------------------------------------------------

Began writing an executor for the FSM produced by the defunctionalizer.
Currently, as '+' and '-' are the only primitive operations,
primitive operations may only return integers, and the evaluator
used for primitive operations in the executor currently makes this assumption.

Still need to write a simple command line for interaction; presently,
only the transition functions and a primitive-evaluator are built.

----------------------------------------------------------------------
-- 24.03.09
----------------------------------------------------------------------

The primary objective at this point is to get the defunctionalizer
working on the example(s) in "~/cheapthreads/ctc/tests/SecureQ".
For this, the following are needed:

  + Additional components in the state for IPC signalling
    (done -- these are encompassed by 'defaultK' in DefunTypes)
  + A Re-defunctionalizer, which will be identical to the R-defunctionalizer
    as applied to 'step', but differing in that it will have a treatment
    of 'signal', presently defined as:

      signal x ==defun==> (pc, req, rsp, ports, rts, ... )
                            |-> (HANDLER, x, rsp, ports, pc, ...)

    where 'HANDLER' is a label referencing the first state in a
    defunctionalized handler

  + Small modifications to the main defunctionalizer procedure so that
    the handler is processed and patched into the final state machine
  + Possible need for additional base types; currently, K accepts
    as states only those base types defined in the paper; according to the
    monad declarations in SecureQ, values of other type may appear here,
    necessitating either a translation into base types, or the addition
    of new base types.  New types will probably be required for
    'req' and 'rsp', as these use the constructed types given in SecureQ.
    It might also be possible (but is it desirable?) to use base types
    to simple encode the appropriate values in these registers.

Although the monad declaration in "~/cheapthreads/ctc/tests/secureq/qmonad.hs"
introduces new components, it appears it does not make any express mention
of req, rsp, rts, or ports as part of the state; the new components
should not conflict.

----------------------------------------------------------------------
-- 01.04.09
----------------------------------------------------------------------

Since complete treatment of SecureQ by the frontend is pending,
continued work on the executor.  Added a simple a loop for stepping through.
Currently there are no commands; '\n' steps, and any other key quits.
Discovered a bug in earlier work in the executor that did not correctly
handle parameters as values.  Specifically, evaluation of primitive
operations might require the fetching of a value bound to a parameter; this
parameter would reference a register that might itself contain a parameter.
In particular, a register that is not changed would contain a parameter
referencing itself, which would then lead to an infinite loop.  Attempted
to deal with this by adding explicit mention of current values in the
registers, though I am not entirely convinced this is the best solution.

Encountered a problem that may pertain to either to the defunctionalizer,
or the executor, or both: in the dslwc example, main is defined in terms
of a fixpoint lambda expression applied to constant arguments; the state
machine currently produced does not take these initial values into account;
as a result, the machine attempts an invalid primitive operation.  Further
study is needed to determine what about this construct prevents correct
initialization, and how to appropriately handle it.

LATER: after discussion with Adam, implemented a satisfactory solution to
the initialization problem; fix applications are always fully-applied
lambda terms, and constant arguments should appear only in these cases.
Added a special "INIT" state to the FSM, with a transition either to
PC := 0 or to the appropriate fixpoint label.  Currently, however,
identifiers are being either lost or misnamed; this appears to be
a bug in the executor, since no inconsistencies can be observed elsewhere.

----------------------------------------------------------------------
-- 02.04.09
----------------------------------------------------------------------

Fixed previously mentioned initialization bug; this was a result of using
empty states to initialize the executor.  Fixed this by adding an empty list
case to function getval in DFExec that returns the nil value.

Changed initialization conventions so that executor no longer begins with
an empty state.

Executor still enters an infinite loop while evaluating primitives.

----------------------------------------------------------------------
-- 03.04.09
----------------------------------------------------------------------

Investigating infinite loop in primitive evaluation lead to discovery of
subtler problems in initialization; tweaked the initial case for a main
function consisting of a top-level fixpoint application so that first
transition (i.e. that from "INIT") write the initial arguments of fixpoint
to the appropriate virtual registers.  Infinite loop in evaluator was
an indirect consequence of the fact that registers were being written over
with their own parameters; the evaluator would, in turn, attempt evaluation
of the parameter, leading to an evaluation of a parmaeter etc.  Although
the corrections to initialization fixed this bug, the fact that such a loop
is possible suggests that the evaluator is not especially robust and should
be rewritten at some point.

Observed that some of the confusion leading to the problem above is caused
by the implicit use of two sets of type-equivalent states that are used
differently.  Type VReg in the executor is essentially just a single
component of a KState, and both are used by a number of executor functions.
Although the name difference clarifies what the function is doing, it
should be clearly distinguished that while KState is used by the executor as
an "immutable" template of what the next operation will be, VReg is used
to store the values produced by the preceding step.  That is, KState
characterizes transitions, and VReg serves as memory.  It would be helpful
in the future if this distinction was made better apparent.

Executor now runs the dslwc example.  The example appears to run correctly.

----------------------------------------------------------------------
-- 08.04.09
----------------------------------------------------------------------

Began work on functions to write the FSM output in concrete syntax of
Agron's FSMLang.  In course of doing so, discovered that it might be
helpful to retain type annotations at some point in the defunctionalization
preprocessing; unfortunately, it is not immediately clear where, and
existing code has been written to disregard or discard type annotations
by convention.  The primary complication comes from the fact that
lambda-bound variables may or may not (need to check) have a type that
is explicit from any annotation.  This line of work also leads me to believe
that it may be desirable at some point to refactor the code so that
there are separate K-State and K-Spec types; presently, the defunctionalizer
uses the same type for specifying and for manipulating states, which has
lead to some confusion in the past.

One point that should be noted here is that the FSM produced by
the defunctionalizer still allows types of any primitive value
as values of its state components, while FSMLang uses fixed types
for its signal (i.e. state component) values.  This may or may not
need to be addressed in the future.

----------------------------------------------------------------------
-- 10.04.09
----------------------------------------------------------------------

Made slight changes to the preprocessor so that when variables are collected
into state components their types are suffixed to the component label.
This should allow access to the type annotations when writing the FSMLang
concrete syntax without requiring major changes to the data structures
already in place.  It should be noted, however, that this points to
a weakness in the overall program architecture: during preprocessing,
variable names in the program text and their corresponding register labels
are manipulated independently, sometimes leading to problems that require
tedious repair.  If I were to go back and do things all over again,
I would avoid this issue by doing just one pass of variable-name rewriting
at the start.

We continue the convention of separating 'fields' of the identifier
by spaces (as these won't appear in the original identifier as in the actual
program text); the final field will by the type annotation to be
passed to the FSMLang concrete syntax writer.  The passing of the type
annotation is necessary because FSMLang requires (unsurprisingly) that
the type of a signal (i.e. state component) be specified.

Ultimatley had to apply some rather hacky adjustments to get the type
annotations straightened out; the state creation now operates so that
all state components are initially created with (1) a procedure annotation as
implemented in much earlier work on the preprocessor, and (2) a type annotation.
The type annotation is stripped off by the R-defuncionalizer to keep
consistency with other functions; the same is done by the executor top-level
call.  If this is not done, inconsistencies between register labels
and parameter names arise.  Though this is rather byzantine, it is the solution
that entailed the least extensive modifications to the code.

----------------------------------------------------------------------
-- 10.04.09
----------------------------------------------------------------------

More work on output of FSMLang concrete syntax; at the present stage we make
the following (expedient) assumptions:

  + all CTS default states, i.e. rts, rsp, req, ports, retval
    are assumed to have type std_logic_vector
  + all other states are either (VHDL) integer or (VHDL) boolean 
  + only simple structures will be handled, e.g. no for-loops
  + no IO channels or external ports

This obviously gives us an extremely simplified production, but enough
basic facility to produce a semblance of the concrete syntax.

----------------------------------------------------------------------
-- 24.04.09
----------------------------------------------------------------------

Finished a first version of FSMLang concrete syntax output.  This
presently assumes that the transition function is well-defined
and deterministic, i.e. each state transitions to one and only one
other state.  Suspect that this will be sufficient, though this
remains unproven so far.

----------------------------------------------------------------------
-- 06.07.09
----------------------------------------------------------------------

Beginning work on compiling the SecureQ example; see

  ~/cheapthreads/ctc/ct/tests/secureq/secureq.hs

for the CT source of this.

At this stage, our main focus is the compilation of this particular
example, and so some short-cuts and temporary kludges are likely
to be used as expeditious.  These will be noted in the inline comments
(with a log date) wherever they occur.

In particular, we have chosen to temporarily circumvent the type-checker.
However, the defuncitonalizer does use type-annotations, which the type-checker
is responsible for producing.  The use of these has been removed where
necessary, and replaced with dummy types.

Added a special case to the top-level defunctionalizer call, defunr,
to deal with calls to 'signal' arising in Re.  This should be possible,
because it is only the case of a call to signal that the defunctionalization
rules for Re differ from those for R.  It should be noted that the
defunctionalizer assumes the existence of a 'handler' routine with a standard
label (value set by string value of constant 'handlerL') that is jumped to
in the instance of a call to signal.

Note that the five essential system components, i.e the state return value,
request, response, ports, and return address (for jumps back from handler)
have all been resituated at the front of the state list.  The location of
these five components as the first five in the state list should be standard
from this point onward.

----------------------------------------------------------------------
-- 07.07.09
----------------------------------------------------------------------

Wrote a simple handler FSM to be pasted in to rules produced at the final
stage of defunctionalization.  The FSM is extremely simple, but uses some
particular conventions, and its construction has revealed some needed changes
to the code elsewhere.

The handler FSM is the first so far to involve multiple transitions from
a particular state; review of Agron's FSMLang paper reveals that this
is acceptable, and can be compiled into FSMLang.  However, current
code for the defunctionalizer may have overlooked this (obvious)
possibility.

It should also be noted that the handler, as written, assumes no state
beyond the default 'system' states.  Up to this point, the specification
of state transitions as total maps between the components of states
has been assumed; the handler, however, manipulates only the system states
and requires no knowledge of other state components.  The use of
total-mapping transitions may have been an expedient in earlier development
that can now be discarded, or it may require some further modifications.
It should be noted that Agron's language does NOT use or require total
maps in its transitions; only components that change are given in transition
rules.

Several provisional 'values' have been added to DefunVal to accomodate
the new signaling values, i.e. Cont, Ack, etc.  These are purely to indicate
the placement of these values in the state, and are provisional;
they will need to be elaborated at a later time, in order to allow
the formation of proper FSMLang at final output.

Encountered what may become a future problem regarding the transition back
from the handler; in particular, the rts value must be given as an integer
in order to produce a meaningful PC; unfortunately, the transition rule itself
has no knowledge the actual integer value of the PC.  Have worked around this
by using 'rts' as a label, which (is supposed to) cue to transition to
PC equal to the value of the rts component.

LATER:

Defunctionalizer enters an ininite loop when applied to SecureQ in its current
form; added a 'main' function to SecureQ, though this is a trivial change.

Closer inspection revealed that nullary functions -- of which there are
a number in SecureQ -- are being parsed as 'CtsVar', which makes it likely
that they are not being properly inlined, which may be leading indirectly
to the infinite loop.  Further probing suggests that the loop is located in
the functions that collect and rename lambda-bound variables, in which case
these might represent two different problems.  Commenting out these functions
allows the defunctionalizer to terminate, but the output it produces is
clearly wrong, in that it produces invalid transitions (labels are
identifiers from the code, no matching initial and terminal states),
and the FSM is clearly far too small.  This is consistent with the suggestion
that functions are not being inlined as expected.

----------------------------------------------------------------------
-- 08.07.09
----------------------------------------------------------------------

Discovered that infinite loop was not the result of a bug, but
of an overlooked recursive function in the SecureQ code that caused
the inliner to attempt to inline a recursive call.  The function
in question was 'handler', and as the defunctionalizer already
applies a hard-wired handler, we have elected to omit the CT-code
handler from the example for now.  Suggest that it could probably
be implemented as a fix-point, but have put that matter aside for now.
It should be noted that 'handler' is not actually called anywhere within
the SecureQ example, and so its ommission should cause no problems.

Defunctionalizer still produces bad labels.

LATER:

The bad labels appear to arise from unfinished parts of defunr; in particular,
these are being pasted in from the 'isRec' case of the guarded equations,
since this was originally a kludge pushed in to allow recursive calls to 
be properly dealt with.  (This may be a sign that it needs to be removed.)
The function would fall through to this case because stepRe was not being
recognized and treated as stepR, which for all practical purposes, it should be.

Encountered problems in dealing with the 'setlocMem' and 'putlocMem' functions;
these were called, but not defined in Adam's adaptation, and, though their
definitions exist in the original SecureQ code, they use higher-order functions
in a way that seems difficult to extricate.  Suggest attempting to rewrite
these in a purely monadic style.

Also need to build in support for constructed-types-as-values.  Also need to
produce definitions for the new boolean primitives, i.e. '==' etc.

For now, the former is being handed by extending DefunVal with a new case
specially handling constructed types; it will be assumed at this point that
the actual type will be resolved at the final state of compilation,
i.e. in the process of writing FSMLang.  Problems here are also likely
germane to the extension of the primitives definitions.

It should be noted that the DefunVal is being very liberally extended,
suggesting that it is being heavily used as an intermediate representation.
As such, it may be wise to give more careful thought to its structure
and translation.

----------------------------------------------------------------------
-- 09.07.09
----------------------------------------------------------------------

Minor crisis arising from the need to introduce non-trivial branches;
for some strange reason, this was neglected, probably because there
were none in the trivial examples initially tried.  'DefunVal' will have
to be extended even further.  Closer inspection suggests that intended
(but perhaps unstated) purpose of the DefunVal type was to represent values
that can be written to FSMLang; additions that are now organically appearing
seems to be tending in this direction, whereas those types originally 
produced were largely perfunctory place-holder.

Suggest restructuring DefunVal to reflect exactly those values that can
be represented as the components or boolean guards of FSMLang rules.
Constructed types will still be allowed; these will be worked out,
again, at the final back-end.

Perhaps more appropriate, K-transitions needs to be reformulated
to include a possible boolean guard; this would require changes to both
transition rules and to DefunVal.

As such, it remains unresolved how evalCtsExpr, which determines K-transitions,
should handle if-then-else expressions.
is presently unresolved.

----------------------------------------------------------------------
-- 13.07.09
----------------------------------------------------------------------

Proposed solution to handling of conditional expressions:

The structure of a well-formed CT program is such that a conditional
expression produces a well-defined list of possible values.  It should be
noted that this requires that if-then-else is always typed as a K-term,
i.e. it is involved in purely stateful, terminating operations -- only the
values of particular state components can change, never any aspect of control-
flow.

Thus, a transition from one state to another can be expressed as a pair of
paired identifier-value tuples (in our implementation, corresponding lists
of identifier-value pairs); the solution to the if-then-else problem
can thus take the form of an augmentation to the structure of 'value'
to admit the notion of conditional-value.  Thus, 'value' can be extended
such that it may consist of a single primitive value, or a finite,
well-defined list of alternative primitive values, each with a corresponding
boolean condition.  This can readily be transformed into a corresponding
list of guarded FSMLang rules, each with the same state label (assuming
that this is how guarded transitions work in FSMLang), and each with
the same next-state in the transition-header.

Thus (1) 'value' i.e. DefunVal in our implementation is an ordinary value
or a 'conditional' value consisting of a list of values, each with its own
boolean condition; (2) this suggests that the left- and right-hand sides of
a K-transition should be given different types, since we likely do not
to permit conditional values to occur on the left-hand side of a rule --
this could have weird consequences; (3) the expression evaluator,
evalCtsExpr, should be modified to produce 'conditional' values as its
output when applied to a if-then-else expressions; (4) the final back-end
will then be required to sift through the right-hand side of any transition,
identify any conditional values, partition them according to their boolean
conditions, and then write a guarded FSMLang transition rule corresponding
to each condition.

LATER:

Note that the structure the CT abstract syntax admits the unlikely
(but technically present) possibility that an if-then-else expression
may guarded by another if-then-else expression, i.e. the predicate
controlling evaluation may itself be conditional.  May or may not
disregard this possibility in extending the evaluator; the issue
is relevant because the boolean condition itself must be evaluated.

Proposed temporary resolution:

The expression controlling the if-then-else must be typed boolean;
it is possible, but unlikely, that it will be anything other than
an expression that can be evaluated to a primitive boolean
operation (i.e. '==' or '!=').  To be expeditious, we will for now assume 
that the controlling expression IS of this form, and translate it
directly into a 'BoolGuard' term to be used for a conditional value;
this guard will be applied to the (possibly conditional) values
produced by evaluating the 'if' half of the expression; the 'else'
will produced by applying the negation of this guard to the evaluation
of the complementary expression.

----------------------------------------------------------------------
-- 15.07.09
----------------------------------------------------------------------

Built the conditional-value monad into a new evaluator; evaluator is
not yet hooked up to the K-defunctionalizer.  This is pending possible
extensions to the K-defunctionalizer that will further integrate B
into the defunctionalization process.

The old evaluator is still used in some special cases to produce
ordinary, non-conditional values (i.e. DefunVal); right now, this is
only in places that it has been expeditious to assume do NOT contain
if-then-else expressions, i.e. in the arguments of a constructor,
or in the boolean expression heading an if-then-else.

The function 'toGuard' used to convert a (presumably) boolean expression
into a BoolGuard is presently a stub. It covers the boolean tests that we
currently expect, i.e. '==' and '!=', but does not cover a wider range
of cases, i.e. the possible definition of predicates used to control
if-then-else.

LATER:

Working the new evaluator in the the top-level K-defunctionalizer.
In the course of this, observed several minor type conflicts that need to
be sorted out.  This applies especially to 'case' expressions, which
extend the local environment (i.e. current state) with the identifiers
used in their patterns.  These are still connected to the old evaluator,
and will need to be reworked accordingly.

In particular, type conflicts prevent the use of the old evaluator in certain
cases (see above) as had originally been planned.  I no longer believe it
is practical to attempt to use two tiers of evaluation, i.e. to evaluate
some expressions inside of the B-monad and others outside of it.  It might
be workable to simply project values out of the monad in these cases,
but this could easily lead to bugs in the defunctionalizer later, and/or
unnecessary complications in coding.  The same time, these cases need
to be dealt with, and it is questionable whether there is any real danger
in simply projecting out of the monad in order to expedite the simple
SecureQ example.

----------------------------------------------------------------------
-- 1.07.09
----------------------------------------------------------------------

Went ahead with plan to deal with requiring simple, non-conditional values
in constructor applications by projecting out of the B-monad.  For the time
being, this should be an acceptable solution, since projecting out of B
requires that the condition be evaluated, and the 'Condition' (see BMonad.hs)
instance declaration for 'BoolGuard' has been stubbed for now to throw an
error.  This should prevent the simplifying assumption from being covertly
violated, while preventing any major restructuring of types that might
entangle simple values (DefunVal) and conditional ones (RHVal), which
needs to be avoided.

Finished adjusting types; these turned out to require only superficial
revisions to existing functions, many of which remain identical,
requiring only different type signatures.  (I have made the type signatures
explicit, and hence the code redudant, just to emphasize this fact.)
New evaluator is now integrated into a new main K-defunctionalizer function.

Made very broad but superficial changes throughout the code for the purpose
of accomodating the new conditional values. These changes required no
essential variation in the way functions work; they largely entail the
application of 'return' in B to ordinary 'DefunVal', and the change
of a few type signatures.  The changes have been noted in the inline comments,
and we have consistently used to the convention that functions thus changed
are suffixed with 'Plus'.  Made similar changes to 'handler_routine',
but without producing a duplicate.

The changes have now been propagated up to the top-level defunctionalizer.

----------------------------------------------------------------------
-- 17.07.09
----------------------------------------------------------------------

Discovered a bug that manifested as a failure to properly inline
nullary applications.  Some investigation revealed that this was an
unexpected interaction with an earlier kludge that let unrecognized
function declarations simply pass through, under the assumption that these
were primitives (see 01.03.09).  A subsequent solution to the primitve
operations problem made this kludge obsolete, but it was not removed.
This, in turn, masked the fact that primitive ops were actually not being
recognized as expected, due to an unaccounted-for omission from the
list of declared functions used by the inliner.

Originally, a list of built-in functions was being appended to the list
of function declarations before any of the preprocessor transformations
were applied; for reasons that are presently unclear, these built-ins were
being dropped from the list.  Appending them a second time, during the
final reformulation of the declared functions table used by the preprocessor,
seems to solve the problem, though it is unclear why.  Concerned that
this may in fact be masking some other problem.

Have removed the kludge that allowed undeclared functions to pass through
the preprocessor; these should now throw an exception if encountered.

LATER:

Devised a solution the problem of implementing addressable memory.

Propose (1) setting aside 'Memory' as a reserved type-keyword; (2) treating
memory accesses as primitive operations that can be "taken for granted",
along the lines of '+' or '=='; (3) for each state component declared to have
type 'Memory', introduce a corresponding declaration in the 'MEMORY' block of
the output FSMLang file ; (4) translate all memory access 'primitives' into
the array-style syntax used by FSMLang.

Discovered that the kludge used to permit primitive operations was also
being covertly used to allow fixpoint applications through; as such,
removing it causes fixpoint application to throw an exception.

Suggest 'localizing' the fixpoint parameter in the same way that other
lambda-bound variables are, and then tagging it with a " fix" suffix.
When a function application is encountered, it can then be detected
as a fixpoint application and allowed to pass through the inliner.

----------------------------------------------------------------------
-- 20.07.09
----------------------------------------------------------------------

Implemented the fixpoint solution mentioned above; re-added the
'fixfix' constant, though this has a leading space which has to be
accounted for when testing for the presence of the suffix.  Thus,
applications of the fixpoint should now be tagged so that they are
recognized by the inliner, or any other function down the line that should
make a note of their special status.

Debating the need to promote the arguments of 'PrimOp' to full conditional
values; these were ordinary values, i.e. 'DefunVal', but difficulties arise
because the 'PrimOp' constructors are applied to conditional i.e. 'RHVal'
arguments by the new evaluator.

No solution to this problem is yet in place, despite a lengthy attempt
to resolve the matter.

The duplicate version of the code that used the old, non-conditional
data structure for evaluation have been shut off, at least temporarily,
to prevent extraneous type errors from complicating attempts to
deal with the issue of representing primitive operations within
the conditional value monad.


----------------------------------------------------------------------
-- 21.07.09
----------------------------------------------------------------------

Resolved yesterday's issue regarding primitive operations; no new data
structures were needed, only the proper binding of the FSMOp constructors.

Note that the result of adding conditional values is that n-ary operations
must branch to produce 2^n possible values for each application.  It
appeared at first that this substantial elaboration of the B-term
was unnecessary, and could be glossed over using the assumption that
an if-then-else expression should not appear as the operand of an artithmetic
operator.  This, however, is incorrect; because the evaluator produces B-terms,
and because evaluation proceeds recursively, the primitive operation
constructors must be "threaded" through the term using an appropriate
binding.

Observed another conflict with the implementation of primitive operations;
specifically, these have been, up until now, expressed as tuples which,
in turn were inlined.  This creates a conflict with the evaluator,
which has no meaningful way to evaluate a tuple.  (The former implementation
was itself a kludge, and has now been temporarily stubbed to produce
a nil value.)  Moreover, it appears that this portion of the code
is vestigial; there is no reason that applications of the primitive functions
cannot simply be skipped over, or inlined with identical terms.

Further complications remain, however; inlining functions over themselves
has bad consequences (stack overflow), and simply skipping over
primitive operations creates conflicts with the overarching defunctionalizers.

LATER:

Preserved the tuple implementation for primitive operations for the time being;
again, this only required a proper binding of the operands.  The DSLWC example
is once again working.

Problems remain with SecureQ; no rules are yet formulated for defunctionalizing
whileRe, which uses several structures rejected by the parser, and entails
binding K-terms which are neither 'get' nor 'put'.

----------------------------------------------------------------------
-- 22.07.09
----------------------------------------------------------------------

Talked with Bill; 'whileRe' can be handled as an ordinary fixpoint loop;
the signals employed are all disregarded.  May reimplement this in SecureQ,
or simply write over it in the parser, the defunctionalizer's preprocessor,
or in defunctionalization itself.

LATER:

Re-implemented 'whileRe' in the current SecureQ modification; this is now
a fixpoint function that does "what you would expect a 'while' expression
to do".

Added primitive operation definitions for '>', '<', '<=', '>=' and '!='.

Began a stub to deal with memory accesses in K-terms; these will be
converted into 'get' and 'put' functions and defunctionalized according
to these; the state components manipulated will be locations in an appropriate,
declared memory.

Also began a stub to deal with if-then-else expressions,
which may also occur as a K-atom.  Need to talk to Bill again, as I have
suspicions that this might present problems, indicating that either
(1) 'whileRe' needs a different formulation from that currently being
used in the working (i.e. adapated) SecureQ example, or (2) the language
description needs to be revised to give a better accounting of conditionals.

----------------------------------------------------------------------
-- 24.07.09
----------------------------------------------------------------------

Reformulated the 'whileRe' structure in the SecureQ adaptation to something
closer to the CT style; this formulation appears to be equivalent, but
waiting for confirmation from Bill.

Closer examination suggests that, in fact, if-then-else expressions should
NOT ever appear at the top level of a K-term, i.e. should always appear
within a get or put.

The top-level case for CtsTuple is going to be retained, on the assumption that
we will still use 'read' and 'write' as primitives, and translate them
accordingly into 'get' and 'put'.  This is not necessarily the only place
that this translation could occur, but at the moment I would prefer
simply to treat these particular primitives directly (and keep them
separate in case we change their implementation) rather than adding to
the preprocessor.

Changed 'Memory' from a constructed type to a base type in the front-end,
if only to clearly separate it as it is used by the defunctionalizer.
Added a 'memory write' value to 'DefunVal' in order to represent a memory
write occuring on the right-hand side of a transition rule.  This may or may
not be conceptually sound, but as a provisional measure it should be sufficient.
The new memory write ('DFMemWrite') value is currently applied to two arguments,both 'Int'.  This is adequate for the purpose of SecureQ, but prospectively
could be changed to admit a system of translating arbitrary base values
(i.e. 'DefunVal') into some machine-representable or FSMLang-acceptable
format.

It should be noted that memory accesses, in their current form, have no
protection against attempts to access out of bounds; any address can be
passed as a value produced as an FSMLang program.  It may be that FSMLang
checks this, and there is no need to worry about it, or it may be that
we need to introduce some notion of size into memory.

Did preliminary coding to integrate memory accesses into the main
K-defunctionalizer.  This new code is not complete; 'read' and 'write'
will have rules very similar but not completely identical to those for
'get' and 'put'.  Suggest including in a memory write (or the memory type
itself) a list of addresses written (and their values) and possibly those read
as well.

----------------------------------------------------------------------
-- 27.07.09
----------------------------------------------------------------------

Finished a first implementation of the memory access primitives.  These
embody rules that are similar to those that produce transitions for
'get' and 'put', the only distinction being the use of a 'memory access'
primitive that captures the notion of memory as a mapping whose image
may be different at different steps of a computation.  (This was done
in the original, higher-order version of SecureQ which treated memory
writes as compositions of 'tweek' and memory reads as applications
of the memory function.)

The implementation is completely localized the top level of the
K-defunctionalizer; 'read' is essentially translated into a 'get'
rule that indicates that the value at a certain address in a certain
memory in the 'retval' component, and 'write' simply places a symbolic
representation for "placement of a certain value into a certain location
in a certain memory" in the appropriate state component.

Memory accesses thus only differ from 'get' and 'put' in their use of the
constructed 'memory' values, which do not otherwise appear,
AND SHOULD UNDER NO CIRCUMSTANCES BE PRODUCED BY THE EVALUATOR.

Suggest treating constructed data types as declared constants, at least
for the time being.  All constructed types used in SecureQ are nullary,
and thus can reasonably be mapped to arbitrary (numeric) constants in
FSMLang.

----------------------------------------------------------------------
-- 29.07.09
----------------------------------------------------------------------

Finished groundwork coding to separate states consisting of conditional
values (as in the B-monad) into multiple distinct states guarded by
conditions.  The function that does this is 'unblurK'.  The data structure
manipulations are somewhat complicated, but seem to be correct.  Essentially,
the 'tree' produced as a B-term is separated into its leaves, with a conunction
of conditions attributed to each leaf.  The conjunction is built as
B-terms are bound using '>>=' in the evaluator, and leaves with their
corresponding conditions are obtained by applying 'severB' to the B-term.
'unblurK' then identifies all distinct conditions occurring in a given state,
associates each value in the state to its corresponding condition, and then
separates the "blurred state" into multiple states of ordinary values, with
each such state corresponding to exactly one of the identified conditions.

Discussions continue with Bill regaring the state of the defunctionalization
rules, in particular those applied to 'fix'; it appears that these admit
no possibility for a loop to terminate, which is currently preventing
SecureQ from defunctionalizing correctly.

----------------------------------------------------------------------
-- 2009.11.04
----------------------------------------------------------------------

Work on the defunctionalizer resumes.

----------------------------------------------------------------------
-- 2009.11.06
----------------------------------------------------------------------

Primary objective from several months ago remains: produce FSMLang
for some CheapThreads-equivalent version of the Haskell code in
'~/cheapthreads/ctc/tests/secureq/original/secureq.hs'


Began work to address the absence of conditional loops in CheapThreads;
this is necessary in order to compile SecureQ.  Extended abstract syntax
with a new expression constructor 'CtsSemiFixApp'; this is similar to
'CtsFixApp' except that a new 'CtsExpr' argument precedes the ordinary
fix-arguments.  The expression in the first argument will be evaluated
before executing the body of the loop.  Informally, the expression:

  CtsSemiFixApp sent (k:vars) body args

is equivalent to:

  fix (\k -> ... -> if b then body else return ()) args

The reason that this for CANNOT be used in CheapThreads at present is that
if-then-else expressions may not be typed in R.  The new SemiFix expression
is a syntactic constraint that allows conditional loops without admitting
non-local jumps, which would become possible in the case that if-then-else
could be validly typed in R.

----------------------------------------------------------------------
-- 2009.11.09
----------------------------------------------------------------------

Further work on the parser and syntax;

Format of semifix as:

  'semifix (guard) body' 

creates some minor difficulties for the parser, but these can be resolved
by straightforward modifications to the cases already in place for 'fix';
in the course of making corrections, observed that some of these cases
may not be complete.

Similar fixes resolved a pattern-match failure in the recusion analyzer.

Overall, changes to front-end necessary to accomodate the new syntax are minor.
It should be noted, however, that they have been made in haste and may
overlook some possible (unforeseen) corner cases.

New cases also must be added to the defunctionalizer preprocessor, as the
new syntax entails a new pattern to match against.  Again, these changes are
minor, involving only the insertion of additional cases that are almost
identical to the original cases for 'fix'.

----------------------------------------------------------------------
-- 2009.11.10
----------------------------------------------------------------------

Taking time to work out in scrupulous advance detail how the conditional loop
modifications should be implemented.  The non-termination of fixpoints as
originally specified and implemented greatly simplies the defunctionalization
procedure; terminating loops are somewhat more complicated to defunctionalize.

For a defunctionalized conditional loop L to be correct, it must have
a well-defined INITIAL state, and a well-defined EXIT state, satisfying:

(1) the R-action immediately preceding L must defunctionalize to a
transition whose terminal state is the INITIAL state of L, i.e. the one
corresponding to the "INIT" label in the implementation;

(2) the R-action immediately following L must defunctionalize to a transition
whose initial state S is the terminal state of some transition from EXIT;
that is, there must be a transition (EXIT |-> S), so that S is reachable
from the loop, and S is immediately preceded by the final loop state.

Due to "aggressive inlining", i.e. all functions being inlined so that there
is a total absence of function calls, a CT program at that stage of the compiler
can be thought of as a single R-term consisting of the body of 'main'. It
should be observed that every R term can be deconstructed according to a very
simple grammar:

  R ::= step K | return K | fix R | semifix R | R >>= \P.R | R >> R
  K ::= a term in the K monad
  P ::= a unique lambda-parameter

We also have the following useful property: if the R-term is a 'step'
or 'return', an application of the defunctionalization rule increases the
label-counter by exactly one.

In the case that the R-term is a 'semifix' (we can ignore ordinary fix,
because it will never exit), the label-counter will be in the state
corresponding to the last NUMBERED label in the body of the 'semifix'.  It
should be possible to obtain this value simply by applying 'get' i.e. rdEnv in
the defunctionalizer-environment (called 'M' in "./DefunR.hs" an defined in
"./DefunM.hs"), as:

  defunR(body) >>
  get >>= \i ->
  mkExit i

In order for this rule to work for a complete program, however, EVERY
R-term must defunctionalize so that it begins with a numbered state.
This means that LOOPS MUST BEGIN WITH A NUMBERED STATE which is not the
case presently.  (This is a more general case of A similar problem that
came up some time ago, when it was observed that a program beginning with
'fix' never began execution because the first state of the program was
unreachable.)

It should also be noted that the defunctionalizer from this point forward
needs to implement the following convention:

  * R-terms are traversed in the order that they appear in the source code

This is necessary to ensure that the numbered labels are correctly formed.


-- starting implementation work --

Noticed a let-binding in DefunR (see dated inline comments) that appears to
be either redundant or a logic eror; in particular the body of the expression
does not use the binding, which appears to be important.  This needs to
be revisited after the current work is finished.

Changes also must be made to the portion of the code that produces the initial
states, so that this is consistent with the new numbered-state-first
convention.

Noticed a bug: for some reason, adding a null-bind after the fix-term
(or the semifix term -- these are almost syntactically identical) results
in the evaluation of an expression in which legal, lambda-bound variables
are not included in the environment.

----------------------------------------------------------------------
-- 2009.11.11
----------------------------------------------------------------------

Fixed evaluation bug involving null-bind (see yesterday); this turned
out to be the result of a small oversight in the preprocessor.

Completed first pass at implementing defunctionalization rules for conditional
loops, as described above.  Summarizing:

(1) create a new numbered state S[i] and increment the PC counter to (i + 1);
(2) make a transition from S[i] to S[INITIAL_LABEL] at the head of the loop;
(3) create a new numbered state S[i + 1] and set the PC counter to (i + 2);
(4) make a transition from S[INITIAL_LABEL] to S[i + 2];
(5) defunctionalize the body of the loop according to ordinary rules;
(6) make a transition from S[INITIAL_LABEL] to S[j] where j is the value of
    the PC counter after defunctionalizing the body of the loop, and will
    be the number-label applied to the next new numbered state;

This procedure assumes that R-atoms (i.e. 'step', 'return', 'fix', 'semifix')
are defunctionalized in the order they appear in the code, i.e. so that for
any R-terms R1 and R2 in a term of the form:

  R1 >>= \v -> R2

  if defunR R1 begins with state S[i] and
  if defunR R2 begins with state S[j] then
  i < j

The rules for ordinary 'fix' have also been changed so that the label at the
head of 'fix' is preceded by a new numbered state.

Also added a built-in final state for every FSM ('exit_label', in PreDefun.hs)
which is also preceded by a new numbered state.

----------------------------------------------------------------------
-- 2009.11.12
----------------------------------------------------------------------

Began intergrating thes summer's changes to the K data structures 
(i.e. from "KState" to "KStatePlus") into the code generator.  These
use essentially the same conventions as before, with only small changes.

In general:

(1) strings encoding user-declared identifers have a fixed form as:

      identifer [whitespace] used_in_function [whitespace] type [whitespace]

    where the second words ('used_in_function') is an annotation added
    by the prerpocessor to ensure that lambda-bound variables used in
    different functions are associated to unique identifiers in the
    defunctionalizer output.  The 'type' component is appended to
    the identifier string by the preprocessor as a way to pass type annotaitons
    through the defunctionalizer without disturbing its basic datastructures.
    This last word is broken off and will be used to give identifiers
    appropriate types, once the typechecker is working correctly.

(2) default, built-in functions are preceded by "__" and do not have
    an a associated function identifer as in (1), but do have a type
    annotation as the last word in the string.

I re-emphasize that the K-State type is somewhat overloaded, being used to
represent both abstract state structure and actual bindings within the state.
The FSM code generator uses KState in the former role to generate signals,
i.e. takes the initial KState environment where each identifier is bound
to a 'place-holder' parameter indicating an unchanged value.  'KState' is used
in the latter role to generate transitions.

-- LATER --

It appears that FSMLang allows multiple transitions between two states.
Specifically, it appears that two states may have multiple distinct trasitions
corresponding to multiple distinct actions on the state components.  This
convention will be used to implement conditional values ('if-then-else'), so
that the value corresponding to:

  if p then e1 else e2

will defunctionalize to a pair of transitions as

  S1 [p] |-> S2 {
    do e1;
  }

  S1 [not p] |-> S2 {
    do e2;
  }

where 'do e1', 'do e2' correspond to actions on the state.

-- LATER STILL --

At present, it is assumed that 'signalRe' is not applied to an expression
term containing an 'if-then-else'; this is only a temporary expedient,
and not essential.  Similar assumption for recursive calls inside a fixpoint.

A lot of needless fucking around followed, in order to adjust types.
The difficulty surrounds the integration of the 'conditional value' type into
transition rules. This integration has been done in a rather hurried way that
largely assumes the absence of conditional expressions anyway.  The purpose is
to try to lay the groundwork for building in genuine treatment of conditionals
by making all of the weedy adjustments types and data structures early.  Made
a number of extremely hacky changes that do not deserve comment so much
as out and out revision.

----------------------------------------------------------------------
-- 2009.11.13
----------------------------------------------------------------------

Last nights efforts were not entirely destructive; top-level transition
data structure was changed from 'RRulePlus' into a sum type:

  type Transition = Either RRulePlus (BoolGuard, RRulePlus)

which will facillitate distinguishing conditional from unconditional
transitions in the code generator and elsewhere.

The data structures, however, have become rather convoluted; after
'unblurK' is used to separate conditional states into ordinary states,
the conditional feature of KStatePlus (and by extension, RRulePlus) is no
longer used, and simply clutters up the code with a lot of needless 'V'
constructors.  This is acceptable for the time being, but is a candidate
for refactoring at a later date.

Observed that some lambda-bound variables are being duplicated in the
state-environment constructed by the preprocessor; this is easily worked
around by applying 'nub' to the output of 'mkStatePlus', though the duplication
should not happen and represents a minor bug.  This should be investigated
later, but is presently not an issue.

The code generator now produces correct FSMLang for at least simple
conditional loops.

----------------------------------------------------------------------
-- 2009.11.16
----------------------------------------------------------------------

Added a few new operators for boolean conditions ('<', '>', '<=', '>='), which
are useful in the SecureQ example.  These seem to work with no difficulty.

Need to tweek the preprocessor so that it distinguishes memories from other
state components; this should be straightforward.  However, it seems
a little conceptually awkward to treat a memory in the same way as another
state-monad layer.  There has been a persistent weirdness surrounding the
treatment of memories and memory accesses (for instance, treating 'write'
and 'read' as values, described above and in 'DefunTypes.hs'), and this may
stand to be revisted in the future.  I don't suspect any deep logical problems;
the treatment itself just seems unnecessarily counter-intuitive.

Noticed a small change in the abstract syntax that I had not previously
been aware of; monad layers now explicit type constructors corresponding
to whether the layer is state or resumption.  This represents a minor
inconsistency with the defunctionalizer code, which assumed (and still assumes)
fixed names (i.e. "K" for state, "R" for resumption) in the monad declaration
and uses these to determine which monad layers need to become state components.
New code will use the new constructors; old code should be retrofitted later.

Also noted an idiosyncracy of the parser that causes the 'write' and 'read'
expressions added over the summer, e.g.

  write mem loc val

so that 'mem' is parsed as a constructor application.  This is likely due
to the fact that state layers of the monad begin with upper-case letters;
this seemed to be causing the 'write' and 'read' expressions to be dropped
out at code generation.  The code generator didn't seem to recognize these
expressions as state transitions, and seemed to ignore them.

A great deal of extra difficulty trying to work in reads/writes to memory.
'write' had previously evaluated to a constructed value 'DFMemWrite' taking
a memory name and two integers indicating an address and a value to write.
It was necessary to change this so allow an arbitrary DefunVal to stand
in place of an address.  This is necessary in order to allow for references
to unevaluated parameters, i.e. registers or memory locations referenced
in the output code but not read until runtime.

----------------------------------------------------------------------
-- 2009.11.17
----------------------------------------------------------------------

Added more complete support for complex boolean guards; some of these
didn't have cases in the necessary boilerplate.

Observed that function 'idle', along with all of its calls, is being dropped
out of the defunctionalizer output; this may be due to the presence and use
of patterns, which, upon recent inspection, appear to be incorrectly typed.
It is questionable whether the old "unrolled pattern" code correctly
implements the spec.

Suspect defunctionalizer does not handle patterns, and this is the culprit
behind the missing output.  Another possibility is that these calls
involve a mutual recursion that may confuse the defunctionalizer's
inlining procedure.

Because these issues will be potentially very difficult resolve, working
around them by hand-inling portions of SecureQ and otherwise modifying
the code to something semantically equivalent (in terms of the underlying
state machine).

A number of obvious loose-ends in how boolean conditions are handled have
turned up.  Also noted that the constant "condition" 'True' used in unblurring
and flattening conditional values needs to be optimized out to become an
unconditional transition.

SecureQ now goes through the defunctionalizer, after patterns and (indirect)
recursion are removed.  Output is a little messy, and constructed data types
are not quite fully cleaned up.

Noted also that the labels used for recursive transitions may be improperly
repeated, since such a possibility is not presently dealt with by the
preprocessor.  In particular, the label parameter of the lambda expression
in the argument of a 'fix' is not forced to a unique string.

Note also that 'unblurK' prepends a place-holder to the head of its output;
this is a pair consisting of a constant 'True' condition and a state with no
conditional valuations. This is only used by unconditional transitions;
the presence of this value was creating junk output, so it has been discarded.

----------------------------------------------------------------------
-- 2009.11.18
----------------------------------------------------------------------

Added boolean operators '&&' and '||' to the built-in expressions; this allows
them to occur inside of evaluated expressions, which they previously did not.
Also added cases to the evaluator for boolean expressions to be evaluated.
Boolean expressions can now occur inside of expressions occurring as arguments
to 'putK'.

----------------------------------------------------------------------
-- 2009.11.24
----------------------------------------------------------------------

Presently writing a CT version of Jason's back-end code.

This suggests that we add bit-wise logical operations such as those
already built into C; these can be readily transliterated to FSMLang
and only require a few minor extensions.

We will for now assume the C conventions: '&' for bit-wise 'and' and '|'
for bit-wise 'or'.  Shifts will be accomplished using '>>>' and '<<<', though
this is a little too close to the appearance of null-bind.

----------------------------------------------------------------------
-- 2009.11.30
----------------------------------------------------------------------

The need has finally arisen for using the 'getports' feature that had been
stubbed in several months ago.  This will be used to implement reads from the
FSL as occurring in Jason's back-end code.  Slightly changed the definition of
the handler so that the 'getports' request returns a constructed value
'DFRetSig' in the value slot of the state.  This is meant as a semantic
stand-in for the 'fsl_isinvalid()' macro in the Xilinx EDK, which checks
to see whether the last FSL operation returned valid data.  The new value,
'DFRetSig' is currently provisional; it means to represent the bit that
MicroBlaze flips to correspond to success or failure in reading from the FSL.
Since this value depends on the behavior of the external FSL, it must be treated
as an external input.

----------------------------------------------------------------------
-- 2009.12.01
----------------------------------------------------------------------

Ports need to be handled.  In well-formed FSMLang examples, ports appear
to be accessible in the same way as any other FSM signal once declared.
This suggests adding an 'InPort' and an 'OutPort' type and using these
as elements of the state.  However, these are not true state elements;
'StateT(InPort)' should admit only 'get' operations, and 'StateT(OutPort)'
should admit only 'put' operations.

Need to give a more robust and thorough definition of 'read' and 'write'
memory accesses; these are used especially in Jason's back-end.  In particular,
these can appear on the right-hand side of an expression, but it is not
yet made clear what that makes.

----------------------------------------------------------------------
-- 2009.12.10
----------------------------------------------------------------------

Settled on a benchmark example for defunctionalizing the 'ports'
functionality needed to implement the back-end, and put in place minor tweeks
necessary for the example to go forward.  This includes adding a 'signal'
keyword syntactically comparable to 'step'.  Put in place minor conventions
for new builtin.

----------------------------------------------------------------------
-- 2009.12.14
----------------------------------------------------------------------

Upon further reflection, the 'putreq' and 'getrsp' functions (really, values)
(see '~/cheapthreads/ctc/tests/secureq/backend/documentation/re_rules.pdf')
need a specific semantics for their effect on the underlying state.
This could be represented in terms of an abstract handler, invisible to the
thread of execution, or the transition given from defunctionalizing 'signal'
could be expected to place the appropriate response in '__retval'.

Note that type annotations from the parser are still being deliberately dropped.Consider reversing this policy; however, the current method of handling types
by appending their names to the appropriate identifiers is unnecessarily
awkward, and I am hesitant to build on top of it.  Until work at the
defunctionalizer level is more stable, and the type-checker produces more
complete and reliable behavior, types will continue to be ignored.

However, note that even though type annotations are putatively accessible
at the level of 'defunR', no meaningful annotations actually appear in
expressions because the type-checker is still being circumvented.  This creates
problems in distinguishing the two port types.

Sticking to the policy of implementing the simplest possible functionality
up-front, 'signal' is presently assumed to take an unconditional expression in
its second argument.

Added logical negation to the built-ins; strangely, this had not been done
already.  Negation is specified using the token 'not'; non-alphanumeric symbols
induce needless complications in the parser.

LATER:

Addressed problem with type annotations by writing a trivial (but bulky)
work-around in the type-checker that annotates the first (i.e. port) argument
of an application of 'signal' with the type ('InPort' or 'OutPort') of
the argument.  This allows the two signaling cases to be distinguished
and dealt with properly.

Completed implementation of negation for boolean expressions, and added
a case for boolean variables that are accessed  at run-time.

The benchmark ('~/cheapthreads/ctc/tests/secureq/backend/blocking.ct.hs') now
produces something close to concrete FSMLang code, though some of the finer
points of transliterating constructed values need to be worked out.

----------------------------------------------------------------------
-- 2009.12.21
----------------------------------------------------------------------

Just another reminder that we need the bit-wise logical and shift operations.

Also note that there needs to be some method for declaring that components
of the state (not memories) are immediately accessible to an external device.
The DMA device used in the PEIP back-end code is supposed to have direct
access to a number of components of the state, but only begins transfer once
a certain register (i.e. 'length') is assigned a non-zero value.  The
difficulty here is that the values may be any ordinary, permissible type,
and so simply creating another type will not really model the correct behavior.

----------------------------------------------------------------------
-- 2009.12.28
----------------------------------------------------------------------

As expected, the parser chokes on '|' when it is used as an infix operator
in an expression.  Changing bit-wise OR to '|||' to placate the parser,
and bit-wise AND to '&&&' just for the sake of consistency.  Also need
to choose an operator for bitwise NOT, as '~' also chokes the parser.  Going
to use prefix 'bwnot' for this.

Observed that some syntactically invalid programs appear to be slipping
through the parser.  In particular, some instances of 'put' applications
in which a following 'bind' operator has been erroneously omitted parse
and find their way to the defunctionalizer (which interprets them as
function applications with the wrong number of arguments).

Also observed that functions whose identifiers are prefixed by either 'get'
or 'put' result in errors by the defuncitonalizer, which seems to omit
inlining them.  This is probably a consequence of the (extremely annoying)
convention that K-monadic 'get' and 'put' have to be formed as:

  'get[layer identifier]K'

and

  'put[layer identifier]K'

This is a minor issue; fix it later.  In the meantime, changing function
names in the source resolves the issue.

LATER:

Built in the necessary bit-wise operators.

Need to go back to the K-defunctionalizer and un-constrain the expression
form the address field in 'write' so that identifiers (and not just integer
literals) can appear.  In particular, we need to support full-on
symbolic expressions in the 'address' and 'value' fields, or at least
mixed expressions involving both identifiers and literals.  Probably do this
via the strange FSMOp construct, or something like it.

----------------------------------------------------------------------
-- 2009.12.29
----------------------------------------------------------------------

Attempts at compiling the back-end code suggest that there may be problems
in how conditional expressions propagate; the conditional effect appears to
be ending up in places that it should not, or at least where its presence
is very inconvenient.

Currently working around this by (ab)using 'semifix' to get the same
conditional effect.

LATER:

Transliterated back-end code now goes all the way through the defunctionalizer,
and produces an FSM of about 300 states.

The extremely klunky structure of the code, however, has become especially
conspicuous, especially the way in which conditionals and boolean guards
are handled.  Most likely, the current code doesn't deal with these quite
completely or correctly.  However, rewriting it would not be especially
helpful without also rewriting most of the rest of the code.

On persistent problem remaining is how to initialize a variable for use as
a condition for a loop.  Although there are ways to kludge around this,
they require wasting at least one variable; it would be better if we could
form the condition the way normal people do.

----------------------------------------------------------------------
-- 2009.12.30
----------------------------------------------------------------------

Slightly changed the convention for generating unique identifier names
between functions; new convention is:

  "identifier_function"

instead of

  "identifier function"

, since subsequent code changes have caused 'function' to be dropped in
the output.

Had to do some other minor twiddling with the output functions in the
'WriteFSM' module, as some brittle eccentricities of the conventions
were causing single-character identifiers to be output as empty strings.

We also need to disallow tick-marks (i.e. ') in identifier names at
the parser level, since FSMLang attaches a special meaning to an identifier
followed by a tick.

Also changing the final output of unit (i.e. "()") since, naturally, this
is not a sensible VHDL value.  For now, I'll use the convention that
"()" in the source translates to "0" in the final output.  Similarly for
'NilVal'.

More output twiddling for consistency with an FSMLang spec provided by
email correspondence with Jason.

In the course of cleaning up the output, I also realized that we need
to somehow change the way 'retval' is translated into FSMLang.  The reason for
this is that retval, while it may hold anything that is a well-formed value
according to the CT spec, must be declared to have a single VHDL type in the
FSMLang output.  Because there is really no way to translate CT values into a
single VHDL type, retval can't be used in FSMLang as it is in the CT semantics.

Two proposed solutions: (1) represent 'retval' as a generic logic vector,
with values encoded/decoded as needed, or (2) have multiple 'retval's, one
for each necessary type.

----------------------------------------------------------------------
-- 2009.12.31
----------------------------------------------------------------------

More output twiddling; now output unit and nilval as "-1".

It appears that certain outputs are determined in multiple places, probably
due to the convoluted structure of the DefunVal type, and its relatives.

Observed a malformed program that both the front-end and the
defuncitonalizer failed caught.  Said program contained:

  semifix (condition) (\k -> put...K(...))

which should not be permitted, since 'put' is not encapusulated within
a resumptive application, e.g. step.  However, this program went
through and resulted in a transition to nowhere, labeled with 'put...K'.

Had an idea how to handle constructed values: they should be enumerated as
symbolic constants in the 'GENERICS' field of the output.
